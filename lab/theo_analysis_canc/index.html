---
layout: page
title: 非線形自己干渉キャンセラの理論解析
mathjax: true
---

<script src="{{ " /js/math.js " | prepend: site.baseurl }}" charset="utf-8"></script>
<script src="{{ " /js/knockout-3.5.1.js " | prepend: site.baseurl }}" charset="utf-8"></script>
<script src="{{ " /lab/js/numint.js " | prepend: site.baseurl }}" charset="utf-8"></script>
<script src="{{ " /lab/js/nlanalysis.js " | prepend: site.baseurl }}" charset="utf-8"></script>
<script src='https://cdn.plot.ly/plotly-2.16.1.min.js'></script>

<div class="container">
  <form class="row">
    <div class="mb-3">
      このページでは，非線形自己干渉キャンセラの自己干渉除去性能を理論解析します．
      どのような実装になっているか知りたい場合は，ブラウザでこのページのソースを表示して<code>script</code>タグの中身を眺めるか，<a href="https://github.com/k3kaimu/theo_NLAmp_Excel">Excelによる簡易版</a>もあります．
    </div>
    <h3>信号モデル</h3>
    <div class="mb-3">
      送信信号$x$を平均$0$，分散$1$の複素ガウス分布$\mathcal{CN}(0, 1)$に従う信号とします．
      この信号を，電力増幅器に入力して，以下の受信信号$y$を得るとします．
      ただし，$f(x)$はキャンセラで除去可能な成分を表す伝達関数（たとえば電力増幅器の伝達関数）で，$g(x)$は除去不可能な成分の伝達関数で，$f(x)$と$g(x)$は無相関であるとします．
      $$
      y = f(x) + g(x)
      $$
      この受信自己干渉信号に対して，次の非線形自己干渉キャンセラを考えます．
      $$
      c(x) = \sum_{p=1,3,\cdots}^{N_c} c_p x|x|^{p-1}
      $$
      ここで，$c_p$は以下の残留自己干渉電力$I^\mathrm{R}$が最小になるように推定されるとします．
      $$
      I^\mathrm{R} = \mathbb{E}\left[\left| f(x) - c(x) \right|^2\right]
      $$
      このときの非線形自己干渉キャンセラの除去性能を解析します．
    </div>
    <h3>使い方</h3>
    <div class="mb-3">
      下のフォームに増幅器の伝達関数$f(x)$をJavascriptの関数として記述してください．
      引数の<code>x</code>は<a href="https://mathjs.org/">mathjs</a>の複素数オブジェクトであり，<code>v</code>は任意に設定できるパラメータです．
      入力信号<code>x</code>は平均$0$，分散$1$の複素ガウス分布$\mathcal{CN}(0, 1)$に従う信号です．
      <!-- また，IBOと飽和入力振幅<code>v</code>には次のような関係があります．
      $$
      \mathrm{IBO}\text{ (dB)} = 20 \log_{10} v
      $$
      たとえば，IBOは20 dBのときには<code>v = 10</code>です．DE公式の設定は基本的には変更する必要はありませんが，数値計算精度が足りない場合は調整してください． -->
      また，ある単一のパラメータだけを<code>v</code>として振ることができますので，例えばIBOとして振ったり，Rappモデルのスムースネスファクタとして振るなどしてください．

    </div>
    <div class="mb-3">
      <label for="nlfunc" class="form-label">除去可能な伝達関数（増幅器など）</label>
      <code>function (x, v) {</code>
      <textarea class="form-control" id="nlfunc" rows="5" data-bind="value: transferFuncBody"></textarea>
      <code>}</code>
    </div>
    <div class="mb-3">
      <label for="nlfuncG" class="form-label">除去不可能な伝達関数（雑音など）</label>
      <code>function (x, v, Ptot) {</code>
      <textarea class="form-control" id="nlfuncG" rows="5" data-bind="value: transferFuncBodyG"></textarea>
      <code>}</code>
    </div>
    <div class="mb-3">
      <label for="numOfCancOrder" class="form-label">キャンセラの最大次数</label>
      <input type="number" class="form-control" id="numOfCancOrder" min="1" max="100" data-bind="value: numOfCancOrder">
    </div>
    <div class="mb-3">
      <label for="va" class="form-label">パラメータvの計算開始点$v_a$</label>
      <input type="number" class="form-control" id="va" data-bind="value: va">
    </div>
    <div class="mb-3">
      <label for="vb" class="form-label">パラメータvの計算終了点$v_b$</label>
      <input type="number" class="form-control" id="vb" data-bind="value: vb">
    </div>
    <div class="mb-3">
      <label for="numOfV" class="form-label">パラメータvの分割数</label>
      <input type="number" class="form-control" id="numOfV" min="10" max="1000" data-bind="value: numOfV">
    </div>
    <div class="mb-3">
      <label for="vForAMAMPM" class="form-label">AM-AM/PM特性を表示するためのvの値</label>
      <input type="number" class="form-control" id="vForAMAMPM" data-bind="value: vForAMAMPM">
    </div>
    <div class="mb-3">
      <label for="taDE" class="form-label">DE公式の計算開始点</label>
      <input type="number" class="form-control" id="taDE" min="-6" max="-1" data-bind="value: taDE">
    </div>
    <div class="mb-3">
      <label for="tbDE" class="form-label">DE公式の計算終了点</label>
      <input type="number" class="form-control" id="tbDE" min="1" max="6" data-bind="value: tbDE">
    </div>
    <div class="mb-3">
      <label for="numOfDEDiv" class="form-label">DE公式の分割数</label>
      <input type="number" class="form-control" id="numOfDEDiv" min="10" max="1000" data-bind="value: numOfDEDiv">
    </div>
    <div class="mb-3">
      <label class="form-label">AM-AM/PM特性</label>
      <div id='plotAM-AMPM'></div>
    </div>
    <div class="mb-3">
      <label class="form-label">SICR特性</label>
      <div id='plotSICR'></div>
      <div class="mb-3">
        このページにおけるSICR（Self-Interference Cancellation Ratio）特性は受信信号電力と残留電力であり，次のように定義されます．
        $$
        \mathrm{SICR}\text{ (dB)} = 10 \log_{10} \frac{I}{I^\mathrm{R}} = 10 \log_{10} \frac{P_g + P_\mathrm{tot}}{P_g + P_{N_c+2} + P_{N_c+4} + P_{N_c+6} + \cdots} = 10 \log_{10} \frac{P_g + P_\mathrm{tot}}{P_\mathrm{tot} - P_1 - P_3 - \cdots - P_{N_c}}
        $$
        ただし，$P_g$は除去不可能な成分の電力で，$P_1$, $P_3$, $P_5$, ...はそれぞれ除去可能な成分の線形成分と3次，5次の歪み成分の電力を表しています．
        また，$P_\mathrm{tot}$は除去可能な成分の全電力で，$N_c$は非線形キャンセラの最大次数です．
        $P_n$は伝達関数$f(x)$に対して次のように計算できます．
        $$
        P_n = \left| \mathbb{E}\left[ \psi_n^{*}(x) f(x) \right] \right|^2
        $$
        $$
        P_\mathrm{tot} = \mathbb{E}\left[ \left| f(x) \right|^2 \right]
        $$
        $$
        P_g = \mathbb{E}\left[ \left| g(x) \right|^2 \right]
        $$
        ここで，$\psi_n(x)$は以下のように定義されます．
        $$
        \psi_{2m+1}(x) = \frac{1}{\sqrt{m+1}} L_m^1(|x|^2) x
        $$
        これらの詳細については以下の論文を参照してください．

        <ul>
          <li>K. Komatsu, Y. Miyaji and H. Uehara, "Theoretical Analysis of In-Band Full-Duplex Radios With Parallel Hammerstein Self-Interference Cancellers," in IEEE Transactions on Wireless Communications, vol. 20, no. 10, pp. 6772-6786, Oct. 2021, doi: 10.1109/TWC.2021.3076496.</li>
          <li>K. Komatsu, Y. Miyaji, H. Uehara and T. Matsumura, "Theoretical Investigation and Optimization of Power Amplifier Nonlinearity for In-Band Full-Duplex Radios," in IEEE Transactions on Wireless Communications, vol. 22, no. 5, pp. 3384-3396, May 2023, doi: 10.1109/TWC.2022.3217765.</li>
        </ul>
      </div>
    </div>
  </form>
</div>



<script>



function ViewModel() {
  let self = this;

  this.transferFuncBody = ko.observable(`// Rappモデル
const g = 10**(10/20);   // IBO=10 dB
const s = v;            // パラメータvをsmoothness factorとする
const r = math.abs(x);  // 振幅
return math.multiply(x, (1 + (r/g)**(2*s))**(-1/2/s));`);
  this.transferFuncBodyG = ko.observable(`// 今回は雑音を除去不可能な成分とする．
// Ptotがf(x)の電力として与えられる．
// そのためINR = 80 dBとなるように雑音を付与した状態を理論解析したいなら以下のようにする．
return math.sqrt(Ptot * 1e-8);
`);
  this.numOfCancOrder = ko.observable(7);
  this.numOfDEDiv = ko.observable(100);
  this.taDE = ko.observable(-4);
  this.tbDE = ko.observable(4);
  this.va = ko.observable(0);
  this.vb = ko.observable(15);
  this.numOfV = ko.observable(300);
  this.vForAMAMPM = ko.observable(10);
  this._updateHookForAMAMPM = ko.computed(function(){
    let deint = new makeDEInt(0, Infinity, true, self.numOfDEDiv(), self.taDE(), self.tbDE());
    let func = Function("x", "v", self.transferFuncBody());

    const vvalue = self.vForAMAMPM();

    var traceAM = {
      x: deint.xs,
      y: deint.xs.map(x => math.abs(func(math.complex(x, 0), vvalue))),
      type: 'scatter',
      name: "AM-AM"
    };

    var tracePM = {
      x: deint.xs,
      y: deint.xs.map(x => math.arg(func(math.complex(x, 0), vvalue))),
      type: 'scatter',
      name: "AM-PM"
    };

    var data = [traceAM, tracePM];

    var layout = {
      xaxis: {
        autorange: true,
        title: "AM"
      },
      yaxis: {
        autorange: true,
        title: "AM/PM"
      }
    };

    Plotly.newPlot('plotAM-AMPM', data, layout);

    return true;
  });
  this._updateHookForSICR = ko.computed(function(){
    let numOfCancOrderValue = self.numOfCancOrder();
    let deint = new makeDEInt(0, Infinity, true, self.numOfDEDiv(), self.taDE(), self.tbDE());
    deint = withWeight(deint, x => 2*x*math.exp(-(x**2)));
    let func = Function("x", "v", self.transferFuncBody());
    let funcG = Function("x", "v", "Ptot", self.transferFuncBodyG());

    let paramlist = math.range(self.va(), self.vb(), (self.vb() - self.va())/(self.numOfV()), true);

    function sicr(v) {
      let totP = deint.integrate(x => math.abs(func(math.complex(x, 0), v))**2);
      let totG = deint.integrate(x => math.abs(funcG(math.complex(x, 0), v, totP))**2);
      var resP = totP;
      for(let i = 1; i <= numOfCancOrderValue; i += 2) {
          let nlcoef = deint.integrate(x => math.multiply(func(math.complex(x, 0), v), math.conj(laguerre_norm(i, x))));
          let nlPower = math.abs(nlcoef)**2;
          resP -= nlPower;
      }

      return (totP + totG) / (resP + totG);
    }
  
    var traceSICR = {
      x: paramlist.valueOf(),
      y: math.map(paramlist, x => 10*math.log10(sicr(x))).valueOf(),
      type: 'scatter',
    };

    var data = [traceSICR];

    var layout = {
      xaxis: {
        autorange: true,
        title: "パラメータv"
      },
      yaxis: {
        autorange: true,
        title: "SICR (dB)"
      }
    };

    Plotly.newPlot('plotSICR', data, layout);

    return true;
  });
}

pageViewModel = new ViewModel()
ko.applyBindings(pageViewModel);

</script>