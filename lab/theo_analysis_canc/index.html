---
layout: page
title: 非線形自己干渉キャンセラの理論解析
mathjax: true
---

<script src="{{ " /js/main.js " | prepend: site.baseurl }}" charset="utf-8"></script>
<script src="{{ " /js/math.js " | prepend: site.baseurl }}" charset="utf-8"></script>
<script src="{{ " /js/knockout-3.5.1.js " | prepend: site.baseurl }}" charset="utf-8"></script>
<script src="{{ " /lab/js/numint.js " | prepend: site.baseurl }}" charset="utf-8"></script>
<script src="{{ " /lab/js/nlanalysis.js " | prepend: site.baseurl }}" charset="utf-8"></script>
<script src='https://cdn.plot.ly/plotly-2.16.1.min.js'></script>

<div class="container">
  <form class="row">
    <div class="mb-3">
      このページでは，非線形自己干渉キャンセラの自己干渉除去性能を理論解析します．
      どのような実装になっているか知りたい場合は，ブラウザでこのページのソースを表示して<code>script</code>タグの中身を眺めるか，<a href="https://github.com/k3kaimu/theo_NLAmp_Excel">Excelによる簡易版</a>もあります．
      本ページの結果を論文等で利用される場合は，以下の論文と，また本ページのURLと作者である小松和暉の名前を以下のような形で論文中に明記していただけると助かります．
      <ul>
        <li><a href="https://ieeexplore.ieee.org/document/9425006">K. Komatsu, Y. Miyaji and H. Uehara, "Theoretical Analysis of In-Band Full-Duplex Radios With Parallel Hammerstein Self-Interference Cancellers," in IEEE Transactions on Wireless Communications, vol. 20, no. 10, pp. 6772-6786, Oct. 2021, doi: 10.1109/TWC.2021.3076496.</a></li>
        <li>小松和暉, "非線形自己干渉キャンセラの理論解析", https://blog.toyohashi.nagoya/lab/theo_analysis_canc/.</li>
      </ul>
    </div>
    <h3>信号モデル</h3>
    <div class="mb-3">
      送信信号$x$を平均$0$，分散$1$の複素ガウス分布$\mathcal{CN}(0, 1)$に従う信号とします．
      この信号を，電力増幅器に入力して，以下の受信信号$y$を得るとします．
      ただし，$f(x)$はキャンセラで除去をする対象の非線形伝達関数（たとえば電力増幅器の伝達関数）です．
      $$
      y = f(x)
      $$
      この受信信号に対して，次の非線形自己干渉キャンセラを考えます．
      $$
      c(x) = \sum_{p=1,3,\cdots}^{N_c} c_p x|x|^{p-1}
      $$
      ここで，$c_p$は以下の残留自己干渉電力$I^\mathrm{R}$が最小になるように推定されるとします．
      $$
      I^\mathrm{R} = \mathbb{E}\left[\left| f(x) - c(x) \right|^2\right]
      $$
      このときの非線形自己干渉キャンセラの除去性能や帯域内全二重が達成するSIDNR（所望信号電力/（残留SI+所望信号のひずみ+雑音電力））などを計算できます．
      このページを読み込んだ際の初期値では，<a href="https://ieeexplore.ieee.org/document/9425006">こちらの論文</a>のFig. 6の結果と等価なパラメータや評価指標で理論解析した結果（LNAの効果を省略しているなど，一部異なります）が表示されます．
    </div>
    <h3>使い方</h3>
    <div class="mb-3">
      下のフォームに増幅器の伝達関数$f(x)$をJavascriptの関数として記述してください．
      引数の<code>x</code>は<a href="https://mathjs.org/">mathjs</a>の複素数オブジェクトであり，<code>v</code>は任意に設定できるパラメータです．
      入力信号<code>x</code>は平均$0$，分散$1$の複素ガウス分布$\mathcal{CN}(0, 1)$に従う信号です．
      <!-- また，IBOと飽和入力振幅<code>v</code>には次のような関係があります．
      $$
      \mathrm{IBO}\text{ (dB)} = 20 \log_{10} v
      $$
      たとえば，IBOは20 dBのときには<code>v = 10</code>です．DE公式の設定は基本的には変更する必要はありませんが，数値計算精度が足りない場合は調整してください． -->
      また，ある単一のパラメータだけを<code>v</code>として振ることができますので，例えばIBOとして振ったり，Rappモデルのスムースネスファクタとして振るなどしてください．

    </div>
    <div class="mb-3">
      <label for="nlfunc" class="form-label">非線形伝達関数（増幅器など）</label>
      <code>function (x, v) {</code>
      <textarea class="form-control" id="nlfunc" rows="5" data-bind="value: transferFuncBody"></textarea>
      <code>}</code>
    </div>
    <div class="mb-3">
      下のフォームにはSICRやSIDNR，もしくは達成可能レートなどの評価指標を計算するための関数を記述してください．
      引数の<code>v</code>は掃引するパラメータ（グラフの横軸の値），
      <code>Ptot</code>は$f(x)$の出力電力の期待値，
      <code>PNLlist</code>は$f(x)$の出力に現れる非線形電力のリスト（0番目は線形成分，1番目は3次成分，．．），
      <code>IR</code>は残留自己干渉電力，
      <code>Pd</code>は$f(x)$の3次以上の非線形成分の全電力，
      <code>cancOrder</code>はキャンセラの次数です．
    </div>
    <div class="mb-3">
      <label for="evalPerf" class="form-label">評価指標</label>
      <code>function (v, Ptot, PNLlist, IR, Pd, cancOrder) {</code>
      <textarea class="form-control" id="evalPerf" rows="5" data-bind="value: evalPeformanceBody"></textarea>
      <code>}</code>
    </div>
    <div class="mb-3">
      <label for="numOfCancOrder" class="form-label">キャンセラの最大次数</label>
      <input type="number" class="form-control" id="numOfCancOrder" min="1" max="100" data-bind="value: numOfCancOrder">
    </div>
    <div class="mb-3">
      <label for="va" class="form-label">パラメータvの計算開始点$v_a$（グラフ横軸の始点）</label>
      <input type="number" class="form-control" id="va" data-bind="value: va">
    </div>
    <div class="mb-3">
      <label for="vb" class="form-label">パラメータvの計算終了点$v_b$（グラフ横軸の終点）</label>
      <input type="number" class="form-control" id="vb" data-bind="value: vb">
    </div>
    <div class="mb-3">
      <label for="numOfV" class="form-label">パラメータvの分割数（グラフ横軸の分割評価数）</label>
      <input type="number" class="form-control" id="numOfV" min="10" max="1000" data-bind="value: numOfV">
    </div>
    <div class="mb-3">
      本プログラムではDE公式という数値積分公式を用いています．
      デフォルトの値（$t_a=-4$, $t_b=4$, 分割数101）では87次ひずみ（87次のキャンセラ）の計算がギリギリの精度です．
      これ以上の次数のひずみを計算したい用途はないと思いますが，もしより精度がほしい場合には$t_a$と$t_b$の範囲を広げたり，分割数を増やしてください．
    </div>
    <div class="mb-3">
      <label for="taDE" class="form-label">DE公式の計算開始点$t_a$</label>
      <input type="number" class="form-control" id="taDE" min="-6" max="-1" data-bind="value: taDE">
    </div>
    <div class="mb-3">
      <label for="tbDE" class="form-label">DE公式の計算終了点$t_b$</label>
      <input type="number" class="form-control" id="tbDE" min="1" max="6" data-bind="value: tbDE">
    </div>
    <div class="mb-3">
      <label for="numOfDEDiv" class="form-label">DE公式の分割数</label>
      <input type="number" class="form-control" id="numOfDEDiv" min="10" max="1000" data-bind="value: numOfDEDiv">
    </div>
    <div class="mb-3">
      <label class="form-label">評価結果（<span data-bind="text: textComputeState"></span>）</label>
      <div id='plotPerf'></div>
      <div class="mb-3">
        このページにおけるSICR（Self-Interference Cancellation Ratio）特性は受信信号電力と残留電力であり，次のように定義されます．
        $$
        \mathrm{SICR}\text{ (dB)} = 10 \log_{10} \frac{I}{I^\mathrm{R}} = 10 \log_{10} \frac{P_g + P_\mathrm{tot}}{P_g + P_{N_c+2} + P_{N_c+4} + P_{N_c+6} + \cdots} = 10 \log_{10} \frac{P_g + P_\mathrm{tot}}{P_\mathrm{tot} - P_1 - P_3 - \cdots - P_{N_c}}
        $$
        ただし，$P_g$は除去不可能な成分の電力で，$P_1$, $P_3$, $P_5$, ...はそれぞれ除去可能な成分の線形成分と3次，5次の歪み成分の電力を表しています．
        また，$P_\mathrm{tot}$は除去可能な成分の全電力で，$N_c$は非線形キャンセラの最大次数です．
        $P_n$は伝達関数$f(x)$に対して次のように計算できます．
        $$
        P_n = \left| \mathbb{E}\left[ \psi_n^{*}(x) f(x) \right] \right|^2
        $$
        $$
        P_\mathrm{tot} = \mathbb{E}\left[ \left| f(x) \right|^2 \right]
        $$
        $$
        P_g = \mathbb{E}\left[ \left| g(x) \right|^2 \right]
        $$
        ここで，$\psi_n(x)$は以下のように定義されます．
        $$
        \psi_{2m+1}(x) = \frac{1}{\sqrt{m+1}} L_m^1(|x|^2) x
        $$
        これらの詳細については以下の論文を参照してください．

        <ul>
          <li><a href="https://ieeexplore.ieee.org/document/9425006">K. Komatsu, Y. Miyaji and H. Uehara, "Theoretical Analysis of In-Band Full-Duplex Radios With Parallel Hammerstein Self-Interference Cancellers," in IEEE Transactions on Wireless Communications, vol. 20, no. 10, pp. 6772-6786, Oct. 2021, doi: 10.1109/TWC.2021.3076496.</a></li>
          <li><a href="https://ieeexplore.ieee.org/document/9937181">K. Komatsu, Y. Miyaji, H. Uehara and T. Matsumura, "Theoretical Investigation and Optimization of Power Amplifier Nonlinearity for In-Band Full-Duplex Radios," in IEEE Transactions on Wireless Communications, vol. 22, no. 5, pp. 3384-3396, May 2023, doi: 10.1109/TWC.2022.3217765.</a></li>
        </ul>
      </div>
    </div>
    <div class="mb-3">
      <label class="form-label">（参考）AM-AM/PM特性</label>
      <div id='plotAM-AMPM'></div>
    </div>
    <div class="mb-3">
      <label for="vForAMAMPM" class="form-label">AM-AM/PM特性を表示するためのvの値</label>
      <input type="number" class="form-control" id="vForAMAMPM" data-bind="value: vForAMAMPM">
    </div>
  </form>
</div>



<script>



function ViewModel() {
  let self = this;

  this.transferFuncBody = ko.observable(`// Rappモデル
const vsat = 10**(7/20); // IBO=7 dB
const s = v;              // パラメータvをsmoothness factorとする
const r = math.abs(x);    // 振幅
return math.multiply(x, (1 + (r/vsat)**(2*s))**(-1/2/s));`);
  this.evalPeformanceBody = ko.observable(`// 今回はSICRを評価する
// Ptotがf(x)の電力として与えられるため，INR = 60 dBを満たす雑音電力は以下のようになる．
const Z = Ptot * 10**(-60/10);
// cancOrder次数の非線形多項式キャンセラで除去後の残留自己干渉電力はIRで与えられるのでSICRの理論解析は以下のようになる．
return 10*math.log10((Ptot + Z)/(IR + Z));
`);
  this.numOfCancOrder = ko.observable(7);
  this.numOfDEDiv = ko.observable(101);
  this.taDE = ko.observable(-4);
  this.tbDE = ko.observable(4);
  this.va = ko.observable(0);
  this.vb = ko.observable(5.1);
  this.numOfV = ko.observable(300);
  this.vForAMAMPM = ko.observable(10);
  this.textComputeState = ko.observable("計算完了");
  this._updateHookForAMAMPM = ko.computed(function(){
    let deint = new makeDEInt(0, Infinity, true, self.numOfDEDiv(), self.taDE(), self.tbDE());
    let func = Function("x", "v", self.transferFuncBody());

    const vvalue = self.vForAMAMPM();

    var traceAM = {
      x: deint.xs,
      y: deint.xs.map(x => math.abs(func(math.complex(x, 0), vvalue))),
      type: 'scatter',
      name: "AM-AM"
    };

    var tracePM = {
      x: deint.xs,
      y: deint.xs.map(x => math.arg(func(math.complex(x, 0), vvalue))),
      type: 'scatter',
      name: "AM-PM"
    };

    var data = [traceAM, tracePM];

    var layout = {
      xaxis: {
        autorange: true,
        title: "AM"
      },
      yaxis: {
        autorange: true,
        title: "AM/PM"
      }
    };

    Plotly.newPlot('plotAM-AMPM', data, layout);

    return true;
  });
  this._updateHookForEvalPerf = ko.computed(function(){
    self.textComputeState("計算中...");

    let numOfCancOrderValue = self.numOfCancOrder();
    let deint = new makeDEInt(0, Infinity, true, self.numOfDEDiv(), self.taDE(), self.tbDE());
    deint = withWeight(deint, x => 2*x*math.exp(-(x**2)));
    let func = Function("x", "v", self.transferFuncBody());
    let evalFunc = Function("v", "Ptot", "PNLlist", "IR", "Pd", "cancOrder", self.evalPeformanceBody());

    let plist = math.range(0, (numOfCancOrderValue-1)/2, true);
    let paramlist = math.range(self.va(), self.vb(), (self.vb() - self.va())/(self.numOfV()), true);
    let deintIndexList = math.range(0, self.numOfDEDiv());

    let conjBasisValuesWithWeight = math.map(math.range(1, numOfCancOrderValue, 2, true), p => math.map(deintIndexList, i => math.multiply(math.conj(laguerre_norm(p, deint.xs[i])), deint.ws[i])).valueOf()).valueOf();

    function evaluate(v) {
        let funcvalues = math.map(deint.xs, x => func(math.complex(x, 0), v)).valueOf();
        let totP = math.sum(math.map(deintIndexList, i => math.abs(funcvalues[i])**2 * deint.ws[i]));
        let PNLlist = math.map(plist, p => math.abs(math.multiply(funcvalues, conjBasisValuesWithWeight[p]))**2).valueOf();
        let Pd = totP - PNLlist[0];
        var dstlist = [];
        var IR = totP;
        math.forEach(plist, i => {
            IR -= PNLlist[i];
            dstlist.push(evalFunc(v, totP, PNLlist, IR, Pd, i*2+1));
        });
        return dstlist;
    }

    var evaluatedValues = [];
    var tasks = [];
    paramlist.forEach(v => {
        async function task() {
            self.textComputeState("計算中...進捗：" + (evaluatedValues.length) + "/" + (self.numOfV()) );
            evaluatedValues.push(evaluate(v));
        }
        tasks.push(task);
    });

    processTasksOnIdle(tasks, () => {
        // 終了時の処理
        let data = math.map(plist, p => {
            return {
                x: paramlist.valueOf(),
                y: math.map(math.range(0, self.numOfV()), i => evaluatedValues[i][p]).valueOf(),
                type: "scatter",
                name: (p*2+1) + "次キャンセラ"
            };
        }).valueOf();
        console.log(data);

        var layout = {
          xaxis: {
            autorange: true,
            title: "パラメータv"
          },
          yaxis: {
            autorange: true,
            title: "評価指標 (dB)"
          }
        };

        Plotly.newPlot('plotPerf', data, layout);
        console.log("DONE");
        self.textComputeState("計算完了");
    });  

    return true;
  });
}

pageViewModel = new ViewModel()
ko.applyBindings(pageViewModel);

</script>